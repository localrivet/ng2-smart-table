{"ast":null,"code":"import { LocalSorter } from './local.sorter';\nimport { LocalFilter } from './local.filter';\nimport { LocalPager } from './local.pager';\nimport { DataSource } from '../data-source';\nimport { deepExtend } from '../../helpers';\nexport class LocalDataSource extends DataSource {\n  constructor(data = []) {\n    super();\n    this.data = [];\n    this.filteredAndSorted = [];\n    this.sortConf = [];\n    this.filterConf = {\n      filters: [],\n      andOperator: true\n    };\n    this.pagingConf = {};\n    this.data = data;\n  }\n\n  load(data) {\n    this.data = data;\n    return super.load(data);\n  }\n\n  prepend(element) {\n    this.reset(true);\n    this.data.unshift(element);\n    return super.prepend(element);\n  }\n\n  append(element) {\n    this.reset(true);\n    this.data.push(element);\n    return super.append(element);\n  }\n\n  add(element) {\n    this.data.push(element);\n    return super.add(element);\n  }\n\n  remove(element) {\n    this.data = this.data.filter(el => el !== element);\n    return super.remove(element);\n  }\n\n  update(element, values) {\n    return new Promise((resolve, reject) => {\n      this.find(element).then(found => {\n        found = deepExtend(found, values);\n        super.update(found, values).then(resolve).catch(reject);\n      }).catch(reject);\n    });\n  }\n\n  find(element) {\n    const found = this.data.find(el => el === element);\n\n    if (found) {\n      return Promise.resolve(found);\n    }\n\n    return Promise.reject(new Error('Element was not found in the dataset'));\n  }\n\n  getElements() {\n    const data = this.data.slice(0);\n    return Promise.resolve(this.prepareData(data));\n  }\n\n  getFilteredAndSorted() {\n    let data = this.data.slice(0);\n    this.prepareData(data);\n    return Promise.resolve(this.filteredAndSorted);\n  }\n\n  getAll() {\n    const data = this.data.slice(0);\n    return Promise.resolve(data);\n  }\n\n  reset(silent = false) {\n    if (silent) {\n      this.filterConf = {\n        filters: [],\n        andOperator: true\n      };\n      this.sortConf = [];\n      this.pagingConf['page'] = 1;\n    } else {\n      this.setFilter([], true, false);\n      this.setSort([], false);\n      this.setPage(1);\n    }\n  }\n\n  empty() {\n    this.data = [];\n    return super.empty();\n  }\n\n  count() {\n    return this.filteredAndSorted.length;\n  }\n  /**\n   *\n   * Array of conf objects\n   * [\n   *  {field: string, direction: asc|desc|null, compare: Function|null},\n   * ]\n   * @param conf\n   * @param doEmit\n   * @returns {LocalDataSource}\n   */\n\n\n  setSort(conf, doEmit = true) {\n    if (conf !== null) {\n      conf.forEach(fieldConf => {\n        if (!fieldConf['field'] || typeof fieldConf['direction'] === 'undefined') {\n          throw new Error('Sort configuration object is not valid');\n        }\n      });\n      this.sortConf = conf;\n    }\n\n    super.setSort(conf, doEmit);\n    return this;\n  }\n  /**\n   *\n   * Array of conf objects\n   * [\n   *  {field: string, search: string, filter: Function|null},\n   * ]\n   * @param conf\n   * @param andOperator\n   * @param doEmit\n   * @returns {LocalDataSource}\n   */\n\n\n  setFilter(conf, andOperator = true, doEmit = true) {\n    if (conf && conf.length > 0) {\n      conf.forEach(fieldConf => {\n        this.addFilter(fieldConf, andOperator, false);\n      });\n    } else {\n      this.filterConf = {\n        filters: [],\n        andOperator: true\n      };\n    }\n\n    this.filterConf.andOperator = andOperator;\n    this.pagingConf['page'] = 1;\n    super.setFilter(conf, andOperator, doEmit);\n    return this;\n  }\n\n  addFilter(fieldConf, andOperator = true, doEmit = true) {\n    if (!fieldConf['field'] || typeof fieldConf['search'] === 'undefined') {\n      throw new Error('Filter configuration object is not valid');\n    }\n\n    let found = false;\n    this.filterConf.filters.forEach((currentFieldConf, index) => {\n      if (currentFieldConf['field'] === fieldConf['field']) {\n        this.filterConf.filters[index] = fieldConf;\n        found = true;\n      }\n    });\n\n    if (!found) {\n      this.filterConf.filters.push(fieldConf);\n    }\n\n    this.filterConf.andOperator = andOperator;\n    super.addFilter(fieldConf, andOperator, doEmit);\n    return this;\n  }\n\n  setPaging(page, perPage, doEmit = true) {\n    this.pagingConf['page'] = page;\n    this.pagingConf['perPage'] = perPage;\n    super.setPaging(page, perPage, doEmit);\n    return this;\n  }\n\n  setPage(page, doEmit = true) {\n    this.pagingConf['page'] = page;\n    super.setPage(page, doEmit);\n    return this;\n  }\n\n  getSort() {\n    return this.sortConf;\n  }\n\n  getFilter() {\n    return this.filterConf;\n  }\n\n  getPaging() {\n    return this.pagingConf;\n  }\n\n  prepareData(data) {\n    data = this.filter(data);\n    data = this.sort(data);\n    this.filteredAndSorted = data.slice(0);\n    return this.paginate(data);\n  }\n\n  sort(data) {\n    if (this.sortConf) {\n      this.sortConf.forEach(fieldConf => {\n        data = LocalSorter.sort(data, fieldConf['field'], fieldConf['direction'], fieldConf['compare']);\n      });\n    }\n\n    return data;\n  } // TODO: refactor?\n\n\n  filter(data) {\n    if (this.filterConf.filters) {\n      if (this.filterConf.andOperator) {\n        this.filterConf.filters.forEach(fieldConf => {\n          if (fieldConf['search'].length > 0) {\n            data = LocalFilter.filter(data, fieldConf['field'], fieldConf['search'], fieldConf['filter']);\n          }\n        });\n      } else {\n        let mergedData = [];\n        this.filterConf.filters.forEach(fieldConf => {\n          if (fieldConf['search'].length > 0) {\n            mergedData = mergedData.concat(LocalFilter.filter(data, fieldConf['field'], fieldConf['search'], fieldConf['filter']));\n          }\n        }); // remove non unique items\n\n        data = mergedData.filter((elem, pos, arr) => {\n          return arr.indexOf(elem) === pos;\n        });\n      }\n    }\n\n    return data;\n  }\n\n  paginate(data) {\n    if (this.pagingConf && this.pagingConf['page'] && this.pagingConf['perPage']) {\n      data = LocalPager.paginate(data, this.pagingConf['page'], this.pagingConf['perPage']);\n    }\n\n    return data;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}