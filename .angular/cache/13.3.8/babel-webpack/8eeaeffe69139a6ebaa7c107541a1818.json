{"ast":null,"code":"import { Subject } from 'rxjs';\nimport { Deferred, getDeepFromObject, getPageForRowIndex } from './helpers';\nimport { DataSet } from './data-set/data-set';\nexport class Grid {\n  constructor(source, settings) {\n    this.createFormShown = false;\n    this.onSelectRowSource = new Subject();\n    this.onDeselectRowSource = new Subject();\n    this.setSettings(settings);\n    this.setSource(source);\n  }\n\n  detach() {\n    if (this.sourceOnChangedSubscription) {\n      this.sourceOnChangedSubscription.unsubscribe();\n    }\n\n    if (this.sourceOnUpdatedSubscription) {\n      this.sourceOnUpdatedSubscription.unsubscribe();\n    }\n  }\n\n  showActionColumn(position) {\n    return this.isCurrentActionsPosition(position) && this.isActionsVisible();\n  }\n\n  isCurrentActionsPosition(position) {\n    return position == this.getSetting('actions.position');\n  }\n\n  isActionsVisible() {\n    return this.getSetting('actions.add') || this.getSetting('actions.edit') || this.getSetting('actions.delete') || this.getSetting('actions.custom').length;\n  }\n\n  isMultiSelectVisible() {\n    return this.getSetting('selectMode') === 'multi';\n  }\n\n  getNewRow() {\n    return this.dataSet.newRow;\n  }\n\n  setSettings(settings) {\n    this.settings = settings;\n    this.dataSet = new DataSet([], this.getSetting('columns'));\n\n    if (this.source) {\n      this.source.refresh();\n    }\n  }\n\n  getDataSet() {\n    return this.dataSet;\n  }\n\n  setSource(source) {\n    this.source = this.prepareSource(source);\n    this.detach();\n    this.sourceOnChangedSubscription = this.source.onChanged().subscribe(changes => this.processDataChange(changes));\n    this.sourceOnUpdatedSubscription = this.source.onUpdated().subscribe(data => {\n      const changedRow = this.dataSet.findRowByData(data);\n      changedRow.setData(data);\n    });\n  }\n\n  getSetting(name, defaultValue) {\n    return getDeepFromObject(this.settings, name, defaultValue);\n  }\n\n  getColumns() {\n    return this.dataSet.getColumns();\n  }\n\n  getRows() {\n    return this.dataSet.getRows();\n  }\n\n  selectRow(row) {\n    this.dataSet.selectRow(row);\n  }\n\n  multipleSelectRow(row) {\n    this.dataSet.multipleSelectRow(row);\n  }\n\n  onSelectRow() {\n    return this.onSelectRowSource.asObservable();\n  }\n\n  onDeselectRow() {\n    return this.onDeselectRowSource.asObservable();\n  }\n\n  edit(row) {\n    row.isInEditing = true;\n  }\n\n  create(row, confirmEmitter) {\n    const deferred = new Deferred();\n    deferred.promise.then(newData => {\n      newData = newData ? newData : row.getNewData();\n\n      if (deferred.resolve.skipAdd) {\n        this.createFormShown = false;\n      } else {\n        this.source.prepend(newData).then(() => {\n          this.createFormShown = false;\n          this.dataSet.createNewRow();\n        });\n      }\n    }).catch(err => {// doing nothing\n    });\n\n    if (this.getSetting('add.confirmCreate')) {\n      confirmEmitter.emit({\n        newData: row.getNewData(),\n        source: this.source,\n        confirm: deferred\n      });\n    } else {\n      deferred.resolve();\n    }\n  }\n\n  save(row, confirmEmitter) {\n    const deferred = new Deferred();\n    deferred.promise.then(newData => {\n      newData = newData ? newData : row.getNewData();\n\n      if (deferred.resolve.skipEdit) {\n        row.isInEditing = false;\n      } else {\n        this.source.update(row.getData(), newData).then(() => {\n          row.isInEditing = false;\n        });\n      }\n    }).catch(err => {// doing nothing\n    });\n\n    if (this.getSetting('edit.confirmSave')) {\n      confirmEmitter.emit({\n        data: row.getData(),\n        newData: row.getNewData(),\n        source: this.source,\n        confirm: deferred\n      });\n    } else {\n      deferred.resolve();\n    }\n  }\n\n  delete(row, confirmEmitter) {\n    const deferred = new Deferred();\n    deferred.promise.then(() => {\n      this.source.remove(row.getData());\n    }).catch(err => {// doing nothing\n    });\n\n    if (this.getSetting('delete.confirmDelete')) {\n      confirmEmitter.emit({\n        data: row.getData(),\n        source: this.source,\n        confirm: deferred\n      });\n    } else {\n      deferred.resolve();\n    }\n  }\n\n  processDataChange(changes) {\n    if (this.shouldProcessChange(changes)) {\n      this.dataSet.setData(changes['elements']);\n\n      if (this.getSetting('selectMode') !== 'multi') {\n        const row = this.determineRowToSelect(changes);\n\n        if (row) {\n          this.onSelectRowSource.next(row);\n        } else {\n          this.onDeselectRowSource.next(null);\n        }\n      }\n    }\n  }\n\n  shouldProcessChange(changes) {\n    if (['filter', 'sort', 'page', 'remove', 'refresh', 'load', 'paging'].indexOf(changes['action']) !== -1) {\n      return true;\n    } else if (['prepend', 'append'].indexOf(changes['action']) !== -1 && !this.getSetting('pager.display')) {\n      return true;\n    }\n\n    return false;\n  }\n  /**\n   * @breaking-change 1.8.0\n   * Need to add `| null` in return type\n   *\n   * TODO: move to selectable? Separate directive\n   */\n\n\n  determineRowToSelect(changes) {\n    if (['load', 'page', 'filter', 'sort', 'refresh'].indexOf(changes['action']) !== -1) {\n      return this.dataSet.select(this.getRowIndexToSelect());\n    }\n\n    if (this.shouldSkipSelection()) {\n      return null;\n    }\n\n    if (changes['action'] === 'remove') {\n      if (changes['elements'].length === 0) {\n        // we have to store which one to select as the data will be reloaded\n        this.dataSet.willSelectLastRow();\n      } else {\n        return this.dataSet.selectPreviousRow();\n      }\n    }\n\n    if (changes['action'] === 'append') {\n      // we have to store which one to select as the data will be reloaded\n      this.dataSet.willSelectLastRow();\n    }\n\n    if (changes['action'] === 'add') {\n      return this.dataSet.selectFirstRow();\n    }\n\n    if (changes['action'] === 'update') {\n      return this.dataSet.selectFirstRow();\n    }\n\n    if (changes['action'] === 'prepend') {\n      // we have to store which one to select as the data will be reloaded\n      this.dataSet.willSelectFirstRow();\n    }\n\n    return null;\n  }\n\n  prepareSource(source) {\n    const initialSource = this.getInitialSort();\n\n    if (initialSource && initialSource['field'] && initialSource['direction']) {\n      source.setSort([initialSource], false);\n    }\n\n    if (this.getSetting('pager.display') === true) {\n      source.setPaging(this.getPageToSelect(source), this.getSetting('pager.perPage'), false);\n    }\n\n    source.refresh();\n    return source;\n  }\n\n  getInitialSort() {\n    const sortConf = {};\n    this.getColumns().forEach(column => {\n      if (column.isSortable && column.defaultSortDirection) {\n        sortConf['field'] = column.id;\n        sortConf['direction'] = column.defaultSortDirection;\n        sortConf['compare'] = column.getCompareFunction();\n      }\n    });\n    return sortConf;\n  }\n\n  getSelectedRows() {\n    return this.dataSet.getRows().filter(r => r.isSelected);\n  }\n\n  selectAllRows(status) {\n    this.dataSet.getRows().forEach(r => r.isSelected = status);\n  }\n\n  getFirstRow() {\n    return this.dataSet.getFirstRow();\n  }\n\n  getLastRow() {\n    return this.dataSet.getLastRow();\n  }\n\n  getSelectionInfo() {\n    const switchPageToSelectedRowPage = this.getSetting('switchPageToSelectedRowPage');\n    const selectedRowIndex = Number(this.getSetting('selectedRowIndex', 0)) || 0;\n    const {\n      perPage,\n      page\n    } = this.getSetting('pager');\n    return {\n      perPage,\n      page,\n      selectedRowIndex,\n      switchPageToSelectedRowPage\n    };\n  }\n\n  getRowIndexToSelect() {\n    const {\n      switchPageToSelectedRowPage,\n      selectedRowIndex,\n      perPage\n    } = this.getSelectionInfo();\n    const dataAmount = this.source.count();\n    /**\n     * source - contains all table data\n     * dataSet - contains data for current page\n     * selectedRowIndex - contains index for data in all data\n     *\n     * because of that, we need to count index for a specific row in page\n     * if\n     * `switchPageToSelectedRowPage` - we need to change page automatically\n     * `selectedRowIndex < dataAmount && selectedRowIndex >= 0` - index points to existing data\n     * (if index points to non-existing data and we calculate index for current page - we will get wrong selected row.\n     *  if we return index witch not points to existing data - no line will be highlighted)\n     */\n\n    return switchPageToSelectedRowPage && selectedRowIndex < dataAmount && selectedRowIndex >= 0 ? selectedRowIndex % perPage : selectedRowIndex;\n  }\n\n  getPageToSelect(source) {\n    const {\n      switchPageToSelectedRowPage,\n      selectedRowIndex,\n      perPage,\n      page\n    } = this.getSelectionInfo();\n    let pageToSelect = Math.max(1, page);\n\n    if (switchPageToSelectedRowPage && selectedRowIndex >= 0) {\n      pageToSelect = getPageForRowIndex(selectedRowIndex, perPage);\n    }\n\n    const maxPageAmount = Math.ceil(source.count() / perPage);\n    return maxPageAmount ? Math.min(pageToSelect, maxPageAmount) : pageToSelect;\n  }\n\n  shouldSkipSelection() {\n    /**\n     * For backward compatibility when using `selectedRowIndex` with non-number values - ignored.\n     *\n     * Therefore, in order to select a row after some changes,\n     * the `selectedRowIndex` value must be invalid or >= 0 (< 0 means that no row is selected).\n     *\n     * `Number(value)` returns `NaN` on all invalid cases, and comparisons with `NaN` always return `false`.\n     *\n     * !!! We should skip a row only in cases when `selectedRowIndex` < 0\n     * because when < 0 all lines must be deselected\n     */\n    const selectedRowIndex = Number(this.getSetting('selectedRowIndex'));\n    return selectedRowIndex < 0;\n  }\n\n}","map":null,"metadata":{},"sourceType":"module"}